Managing work


Once you’ve defined your Worker and your WorkRequest, the last step is to enqueue your work. The simplest
way to enqueue work is to call the WorkManager enqueue() method, passing the WorkRequest you want to run.

val myWork: WorkRequest = // ... OneTime or PeriodicWork
WorkManager.getInstance(requireContext()).enqueue(myWork)

Use caution when enqueuing work to avoid duplication. For example, an app might try to upload its logs
to a backend service every 24 hours. If you aren't careful, you might end up enqueuing the same task
many times, even though the job only needs to run once. To achieve this goal, you can schedule the work
as unique work.


Unique Work

Unique work is a powerful concept that guarantees that you only have one instance of work with a particular
name at a time. Unlike IDs, unique names are human-readable and specified by the developer instead of
being auto-generated by WorkManager. Unlike tags, unique names are only associated with a single instance of work.

Unique work can be applied to both one-time and periodic work. You can create a unique work sequence
by calling one of these methods, depending on whether you’re scheduling repeating work or one time work.

WorkManager.enqueueUniqueWork() for one time work
WorkManager.enqueueUniquePeriodicWork() for periodic work
Both of these methods accept 3 arguments:

uniqueWorkName - A String used to uniquely identify the work request.
existingWorkPolicy - An enum which tells WorkManager what to do if there's already an unfinished chain
of work with that unique name. See conflict resolution policy for more information.
work - the WorkRequest to schedule.
Using unique work, we can fix our duplicate scheduling issue noted earlier.

val sendLogsWorkRequest =
       PeriodicWorkRequestBuilderS<endLogsWorker(>24, TimeUnit.HOURS)
           .setConstraints(Constraints.Builder()
               .setRequiresCharging(true)
               .build()
            )
           .build()
WorkManager.getInstance(this).enqueueUniquePeriodicWork(
           "sendLogs",
           ExistingPeriodicWorkPolicy.KEEP,
           sendLogsWorkRequest
)
Now, if the code runs while a sendLogs job is already in the queue, the existing job is kept and no
new job is added.

Unique work sequences can also be useful if you need to gradually build up a long chain of tasks.
 For example, a photo editing app might let users undo a long chain of actions. Each of those undo
 operations might take a while, but they have to be performed in the correct order. In this case, the
 app could create an "undo" chain and append each undo operation to the chain as needed. See Chaining
 work for more details.

 Conflict resolution policy

 When scheduling unique work, you must tell WorkManager what action to take when there is a conflict.
 You do this by passing an enum when enqueuing the work.

 For one-time work, you provide an ExistingWorkPolicy, which supports 4 options for handling the conflict.

 REPLACE existing work with the new work. This option cancels the existing work.
 KEEP existing work and ignore the new work.
 APPEND the new work to the end of the existing work. This policy will cause your new work to be chained
 to the existing work, running after the existing work finishes.
 The existing work becomes a prerequisite to the new work. If the existing work becomes CANCELLED or FAILED,
 the new work is also CANCELLED or FAILED. If you want the new work to run regardless of the status of the
 existing work, use APPEND_OR_REPLACE instead.

 APPEND_OR_REPLACE functions similarly to APPEND, except that it is not dependent on prerequisite work
 status. If the existing work is CANCELLED or FAILED, the new work still runs.
 For period work, you provide an ExistingPeriodicWorkPolicy, which supports 2 options, REPLACE and KEEP.
 These options function the same as their ExistingWorkPolicy counterparts.
Define work requests

bookmark_border
The getting started guide covered how to create a simple WorkRequest and enqueue it.

In this guide you will learn how to define and customize WorkRequest objects to handle common use cases, such as how to:

    1-  Schedule one-time and recurring work
    2-  Set work constraints like requiring Wi-Fi or charging
    3-  Guarantee a minimum delay in work execution
    4-  Set retry and back-off strategies
    4-  Pass input data to work
    5-  Group related work together using tags

Overview

Work is defined in WorkManager via a WorkRequest. In order to schedule any work with WorkManager y
ou must first create a WorkRequest object and then enqueue it.

Kotlin
Java

val myWorkRequest = ...
WorkManager.getInstance(myContext).enqueue(myWorkRequest)
The WorkRequest object contains all of the information needed by WorkManager to schedule and run your
work. It includes constraints which must be met for your work to run, scheduling information such as
delays or repeating intervals, retry configuration, and may include input data if your work relies on it.

WorkRequest itself is an abstract base class. There are two derived implementations of this class
that you can use to create the request, OneTimeWorkRequest and PeriodicWorkRequest. As their names
imply, OneTimeWorkRequest is useful for scheduling non-repeating work, whilst PeriodicWorkRequest is
more appropriate for scheduling work that repeats on some interval.

Schedule one-time work

For simple work, which requires no additional configuration, use the static method from:

Kotlin
Java

val myWorkRequest = OneTimeWorkRequest.from(MyWork::class.java)
For more complex work, you can use a builder:

Kotlin
Java

val uploadWorkRequest: WorkRequest =
   OneTimeWorkRequestBuilder<MyWork>()
       // Additional configuration
       .build()

Schedule expedited work

WorkManager 2.7.0 introduced the concept of expedited work. This allows WorkManager to execute
important work while giving the system better control over access to resources.

Expedited work is notable for the following characteristics:

Importance: Expedited work suits tasks which are important to the user or are user-initiated.
Speed: Expedited work best fits short tasks that start immediately and complete within a few minutes.
Quotas: A system-level quota that limits foreground execution time determines whether an expedited
job can start.
Power Management: Power management restrictions, such as Battery Saver and Doze, are less likely to
affect expedited work.
Latency: The system immediately executes expedited work, provided that the system's current workload
enables it to do so. This means they are latency sensitive and can't be scheduled for later execution.
A potential use case for expedited work might be within a chat app when the user wants to send a
message or an attached image. Similarly, an app that handles a payment or subscription flow might
also want to use expedited work. This is because those tasks are important to the user, execute
quickly in the background, need to begin immediately, and should continue to execute even if the user
 closes the app

Quotas

The system must allocate execution time to an expedited job before it can run. Execution time is not
unlimited. Rather, each app receives a quota of execution time. When your app uses its execution time
and reaches its allocated quota, you can no longer execute expedited work until the quota refreshes.
This allows Android to more effectively balance resources between applications.

The amount of execution time available to an app is based on the standby bucket and process importance.

You can determine what occurs when the execution quota does not allow for an expedited job to run
immediately. See the snippets below for detail.

Note: While your app is in the foreground, quotas wonâ€™t limit the execution of expedited work.
An execution time quota applies only when your app is in the background, or when your app moves to
the background. As such, you should expedite work that you want to continue in the background.
You can continue to use setForeground() while your app is in the foreground.


Executing expedited work

Starting in WorkManager 2.7, your app can call setExpedited() to declare that a WorkRequest should run as quickly as possible using an expedited job. The following code snippet provides an example of how to use setExpedited():

Kotlin
Java

val request = OneTimeWorkRequestBuilder<SyncWorker>()
    .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)
    .build()

WorkManager.getInstance(context)
    .enqueue(request)
In this example, we initialize an instance of OneTimeWorkRequest and call setExpedited() on it. This
request then becomes expedited work. If the quota allows, it will begin to run immediately in the background.
If the quota has been used, the OutOfQuotaPolicy parameter indicates that the request should be run as normal, non-expedited work.


Backwards compatibility and foreground services

To maintain backwards compatibility for expedited jobs, WorkManager might run a foreground service
on platform versions older than Android 12. Foreground services can display a notification to the user.

The getForegroundInfoAsync() and getForegroundInfo() methods in your Worker enable WorkManager to
display a notification when you call setExpedited() prior to Android 12.

Any ListenableWorker must implement the getForegroundInfo method if you would like to request that
the task run as an expedited job.

Caution: Failing to implement the corresponding getForegroundInfo method can lead to runtime crashes
when calling setExpedited on older platform versions.
When targeting Android 12 or higher, foreground services remain available to you through the corresponding
setForeground method.

Caution: setForeground() can throw runtime exceptions on Android 12, and might throw an exception if
the launch was restricted.

Worker

Workers don't know whether the work they're doing is expedited or not. But workers can display a
notification on some versions of Android when a WorkRequest has been expedited.

To enable this, WorkManager provides the getForegroundInfoAsync() method, which you must implement
so WorkManager can display a notification to start a ForegroundService for you where necessary.

Quota policies

You can control what happens to expedited work when your app reaches its execution quota. To continue,
you can pass setExpedited():

OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST, which causes the job to run as an ordinary work request.
The snippet above demonstrates this.
OutOfQuotaPolicy.DROP_WORK_REQUEST, which causes the request to cancel if there is not sufficient quota.

Deferred expedited work

The system tries to execute a given expedited job as soon as possible after the job is invoked.
However, as is the case with other types of jobs, the system might defer the start of new expedited work, such as in the following cases:

Load: The system load is too high, which can occur when too many jobs are already running, or when
the system doesn't have enough memory.
Quota: The expedited job quota limit has been exceeded. Expedited work uses a quota system that's
based on the App Standby Buckets and limits the maximum execution time within a rolling time window.
The quotas used for expedited work are more restrictive than the ones used for other types of background jobs.
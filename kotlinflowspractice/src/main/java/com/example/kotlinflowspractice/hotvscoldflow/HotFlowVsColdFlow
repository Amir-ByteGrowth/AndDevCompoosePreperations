Types of Flow Builders in Kotlin
Kotlin Flows can be classified into two types based on their behavior:

Cold Flows: These flows start emitting values only when they are collected. They are cold because they
don't do any work or emit values until they have a collector.
Hot Flows: These flows emit values continuously, regardless of whether there are any collectors.
They are hot because they keep producing values even when there are no subscribers.
Here are the main types of flow builders for both cold and hot flows in Kotlin:

Cold Flow Builders

flow {}:
A flow builder creates a cold asynchronous stream that produces values when it is collected.
It allows suspending functions and is used for asynchronous data fetching.

val coldFlow = flow {
    emit(1)
    delay(1000)
    emit(2)
}
flowOf():
Creates a flow that emits a fixed set of values. It is a shorthand for creating simple flows with predefined values.

val coldFlow = flowOf(1, 2, 3)
asFlow():
Extension function to convert various types of collections or sequences into a flow. It turns any iterable or range into a cold flow.

val coldFlow = listOf(1, 2, 3).asFlow()
emptyFlow():
Creates a flow that does not emit any values. This is useful for representing a flow that has no data.

val coldFlow = emptyFlow<Int>()

channelFlow {}:
Similar to the flow builder but provides more advanced control over the emissions. It uses channels
internally and allows the flow to be operated in a concurrent manner.

val coldFlow = channelFlow {
    send(1)
    delay(1000)
    send(2)
}


callbackFlow {}:
A type of cold flow that behaves like a hot flow in that it provides an easy way to convert callback-based APIs into flows.
Internally, it uses a channel and allows sending data from a callback.

val hotFlow = callbackFlow {
    // Example of a callback being used
    val callback = object : LocationCallback {
        override fun onLocationResult(result: LocationResult) {
            trySend(result)
        }
    }
    // Assuming `requestLocationUpdates` is a function to start listening for location updates
    requestLocationUpdates(callback)
    awaitClose { removeLocationUpdates(callback) }
}


Hot Flow Builders

SharedFlow:
A SharedFlow is a hot flow that can be shared between multiple subscribers and will not be canceled when a collector is cancelled.
It's used for broadcasting events to multiple subscribers, similar to LiveData but more powerful and suitable for use with coroutines.

val hotFlow = MutableSharedFlow<Int>()
StateFlow:
A StateFlow is a special type of hot flow that always holds the latest value and emits updates to all collectors. It is similar to LiveData but is fully integrated with coroutines.
Useful for representing a state in UI components that need to react to changes over time.

val hotFlow = MutableStateFlow(0)

Summary
Cold Flows (flow, flowOf, asFlow, emptyFlow, channelFlow): Start producing data only when collected.
Hot Flows (SharedFlow, StateFlow, callbackFlow): Start emitting data immediately and continuously regardless of collectors.
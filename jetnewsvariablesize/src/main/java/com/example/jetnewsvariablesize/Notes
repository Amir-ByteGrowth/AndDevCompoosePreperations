A user’s device is their unique, personal portal into the digital world. As an app developer,
we should let users run the app in the orientation and configuration they prefer. Concretely,
the user gives our app a window: a specific portion of the screen where we can display interactive UI.
Most often this is the entire device screen, but it doesn’t have to be.
If the user wants to use their phone in landscape or portrait, or split-screen multiple apps, they should be able to.
There are many ways that an app’s window may change. To highlight just a few, split-screen support,
foldable devices with an inner and outer display, and resizable windows on Chrome OS all impact your app’s window.
It may be daunting to try to think about supporting each scenario individually, but there is a framing that simplifies the task significantly.
The common thread between all of these scenarios is the screen size available to your app, which is the most relevant piece of
information for displaying your app’s UI in the space the user is giving you. This is the primary reason
why methods Display.getSize() and Display.getRealSize() were deprecated and replaced with WindowMetricsCalculator.computeCurrentWindowMetrics().
For example, if your app is running in split screen mode on a tablet, it shouldn’t try to display “tablet UI”
unless it actually has enough space for it.
This is the mindset we had while revamping Jetnews:
"Given the amount of screen space available to us, how can we best display content describing our app’s state to the user?"
This approach meshes perfectly with the declarative mental model of Compose. Instead of trying to use an
onWindowSizeChanged callback or exposing the changes as an observable Flow, we reduce the size of the window
into a simple piece of observable state. We can now use this state just like any other state in Compose,
combining it with other states in our application to declaratively specify the UI displayed to the user.